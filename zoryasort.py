import tkinter as tk
from tkinter import filedialog, messagebox, ttk
import PyPDF2
import csv
import re
import os
from threading import Thread

class PDFToCSVConverter:
    def __init__(self, root):
        self.root = root
        self.root.title("ZoryaTrace Individual Data Extractor")
        self.root.geometry("600x500")
        self.setup_ui()
        
        # Configure styles
        self.style = ttk.Style()
        self.style.configure('TFrame', background='#f0f0f0')
        self.style.configure('TButton', font=('Arial', 10), padding=5)
        self.style.configure('TLabel', background='#f0f0f0', font=('Arial', 10))
        self.style.configure('TCheckbutton', background='#f0f0f0')
        
    def setup_ui(self):
        # Main frame
        main_frame = ttk.Frame(self.root, padding="10")
        main_frame.pack(fill=tk.BOTH, expand=True)
        
        # Title
        title_label = ttk.Label(main_frame, 
                               text="Individual Data Extractor", 
                               font=('Arial', 14, 'bold'))
        title_label.pack(pady=10)
        
        # Instructions
        instr_label = ttk.Label(main_frame, 
                               text="Select the pdf files you wish to use for the analysis. These files must contain texts written by humans, or by a user to perform an accurate and individual analysis.",
                               wraplength=500)
        instr_label.pack(pady=5)
                               #text="By default, ZoryaTrace has its own database for text data generated by AI; if you wish, you can uncheck the box and provide your own data.",
                               
        
        # Checkbox frame
        checkbox_frame = ttk.Frame(main_frame)
        checkbox_frame.pack(pady=5)
        
        # Use default data checkbox (checked by default)
        self.use_default_var = tk.BooleanVar(value=True)
        default_check = ttk.Checkbutton(checkbox_frame,
                                      text="Use provided AI generated text data",
                                      variable=self.use_default_var,
                                      command=self.toggle_default_data)
        default_check.pack(side=tk.LEFT, padx=5)
        
        # File selection buttons frame
        buttons_frame = ttk.Frame(main_frame)
        buttons_frame.pack(pady=5)
        
        # Add neutral PDF button
        self.add_neutral_button = ttk.Button(buttons_frame, 
                                          text="Add human written PDF(s)", 
                                          command=self.add_neutral_files)
        self.add_neutral_button.pack(side=tk.LEFT, padx=5)
        
        # Add suspicious PDF button (disabled when using default data)
        self.add_suspicious_button = ttk.Button(buttons_frame, 
                                             text="Add AI generated PDF", 
                                             command=self.add_suspicious_file,
                                             state=tk.DISABLED)
        self.add_suspicious_button.pack(side=tk.LEFT, padx=5)
        
        # Selected files listbox
        self.files_listbox = tk.Listbox(main_frame, 
                                      height=8, 
                                      selectmode=tk.EXTENDED,
                                      font=('Arial', 9))
        self.files_listbox.pack(fill=tk.BOTH, expand=True, pady=10)
        
        # File type indicators
        type_frame = ttk.Frame(main_frame)
        type_frame.pack()
        ttk.Label(type_frame, text="Provided human written PDFs:").pack(side=tk.LEFT)
        self.neutral_count = ttk.Label(type_frame, text="0", foreground="blue")
        self.neutral_count.pack(side=tk.LEFT, padx=10)
        ttk.Label(type_frame, text="Provided AI generated PDFs:").pack(side=tk.LEFT)
        self.suspicious_count = ttk.Label(type_frame, text="0", foreground="red")
        self.suspicious_count.pack(side=tk.LEFT)
        
        # Remove selected button
        remove_button = ttk.Button(main_frame, 
                                  text="Remove Selected PDF", 
                                  command=self.remove_selected)
        remove_button.pack(pady=5)
        
        # Progress bar
        self.progress = ttk.Progressbar(main_frame, 
                                      orient=tk.HORIZONTAL, 
                                      length=300, 
                                      mode='determinate')
        self.progress.pack(pady=10)
        
        # Convert button
        self.convert_button = ttk.Button(main_frame, 
                                       text="Extract", 
                                       command=self.start_conversion,
                                       state=tk.DISABLED)
        self.convert_button.pack(pady=10)
        
        # Status label
        self.status_label = ttk.Label(main_frame, text="Ready to extract")
        self.status_label.pack()
    
    def toggle_default_data(self):
        if self.use_default_var.get():
            self.add_suspicious_button.config(state=tk.DISABLED)
            # Remove any existing suspicious files
            items = self.files_listbox.get(0, tk.END)
            for i in reversed(range(len(items))):
                if items[i].startswith("[AI GENERATED] "):
                    self.files_listbox.delete(i)
        else:
            self.add_suspicious_button.config(state=tk.NORMAL)
        self.update_counts()
    
    def add_neutral_files(self):
        filetypes = [("PDF files", "*.pdf"), ("All files", "*.*")]
        filenames = filedialog.askopenfilenames(title="Select human written PDF files", filetypes=filetypes)
        
        if filenames:
            for f in filenames:
                display_name = f"[HUMAN WRITTEN] {os.path.basename(f)}"
                if display_name not in [self.files_listbox.get(i) for i in range(self.files_listbox.size())]:
                    self.files_listbox.insert(tk.END, display_name)
                    # Store the actual file path in a list associated with the listbox
                    if not hasattr(self.files_listbox, 'file_paths'):
                        self.files_listbox.file_paths = []
                    self.files_listbox.file_paths.append(f)
            
            self.convert_button.config(state=tk.NORMAL if self.files_listbox.size() > 0 else tk.DISABLED)
            self.update_counts()
    
    def add_suspicious_file(self):
        filetypes = [("PDF files", "*.pdf"), ("All files", "*.*")]
        filename = filedialog.askopenfilename(title="Select AI generated PDF files (not required)", filetypes=filetypes)
        
        if filename:
            # Remove any existing suspicious file (only one allowed)
            items = self.files_listbox.get(0, tk.END)
            for i in reversed(range(len(items))):
                if items[i].startswith("[AI GENERATED] "):
                    self.files_listbox.delete(i)
                    if hasattr(self.files_listbox, 'file_paths'):
                        self.files_listbox.file_paths.pop(i)
            
            display_name = f"[AI GENERATED] {os.path.basename(filename)}"
            self.files_listbox.insert(tk.END, display_name)
            if not hasattr(self.files_listbox, 'file_paths'):
                self.files_listbox.file_paths = []
            self.files_listbox.file_paths.append(filename)
            
            self.convert_button.config(state=tk.NORMAL)
            self.update_counts()
    
    def update_counts(self):
        neutral = 0
        suspicious = 0
        items = self.files_listbox.get(0, tk.END)
        for item in items:
            if item.startswith("[HUMAN WRITTEN] "):
                neutral += 1
            elif item.startswith("[AI GENERATED] "):
                suspicious += 1
        self.neutral_count.config(text=str(neutral))
        self.suspicious_count.config(text=str(suspicious))
    
    def remove_selected(self):
        selected = list(self.files_listbox.curselection())
        # Need to remove from both the listbox and the file_paths list
        if hasattr(self.files_listbox, 'file_paths'):
            for i in reversed(selected):
                if i < len(self.files_listbox.file_paths):
                    self.files_listbox.file_paths.pop(i)
        for i in reversed(selected):
            self.files_listbox.delete(i)
        
        self.update_counts()
        self.convert_button.config(state=tk.NORMAL if self.files_listbox.size() > 0 else tk.DISABLED)
    
    def start_conversion(self):
        output_file = os.path.join(os.path.dirname(os.path.abspath(__file__)), "data.csv")
        Thread(target=self.convert_files, args=(output_file,), daemon=True).start()
    
    def convert_files(self, output_csv):
        self.update_ui_state(False)
        
        try:
            with open(output_csv, 'w', newline='', encoding='utf-8') as csvfile:
                writer = csv.writer(csvfile)
                writer.writerow(['v1', 'v2', '', '', ''])  # Write header
                
                # Process neutral files
                items = self.files_listbox.get(0, tk.END)
                neutral_files = []
                if hasattr(self.files_listbox, 'file_paths'):
                    for i, item in enumerate(items):
                        if item.startswith("[HUMAN WRITTEN] "):
                            neutral_files.append(self.files_listbox.file_paths[i])
                
                for i, pdf_file in enumerate(neutral_files):
                    self.update_status(f"Processing neutral file {i+1}/{len(neutral_files)}: {os.path.basename(pdf_file)}")
                    self.progress['value'] = (i / (len(neutral_files) + 1)) * 50  # First half for neutral
                    self.root.update()
                    self.process_pdf_file(pdf_file, writer, "neutral")
                
                # Process suspicious data
                if self.use_default_var.get():
                    self.update_status("Processing default suspicious data")
                    self.progress['value'] = 75
                    self.root.update()
                    self.process_default_data(writer)
                else:
                    items = self.files_listbox.get(0, tk.END)
                    suspicious_files = []
                    if hasattr(self.files_listbox, 'file_paths'):
                        for i, item in enumerate(items):
                            if item.startswith("[AI GENERATED] "):
                                suspicious_files.append(self.files_listbox.file_paths[i])
                    
                    for i, pdf_file in enumerate(suspicious_files):
                        self.update_status(f"Processing suspicious file {i+1}/{len(suspicious_files)}: {os.path.basename(pdf_file)}")
                        self.progress['value'] = 50 + (i / len(suspicious_files)) * 50
                        self.root.update()
                        self.process_pdf_file(pdf_file, writer, "suspicious")
                
                self.progress['value'] = 100
                self.update_status(f"successfully extracted. Saved to {output_csv}")
                messagebox.showinfo("Success", f"Successfully extracted at\n{output_csv}")
        
        except Exception as e:
            self.update_status(f"Error: {str(e)}")
            messagebox.showerror("Error", f"Failed to extract and create CSV file:\n{str(e)} . If this error occurs frequently, please open an issue on the github repo.")
        
        finally:
            self.update_ui_state(True)
    
    def process_pdf_file(self, pdf_file, writer, label):
        try:
            with open(pdf_file, 'rb') as file:
                reader = PyPDF2.PdfReader(file)
                
                for page in reader.pages:
                    text = page.extract_text()
                    if text:
                        # Split into sentences (simple approach)
                        sentences = re.split(r'(?<!\w\.\w.)(?<![A-Z][a-z]\.)(?<=\.|\?)\s', text)
                        
                        for sentence in sentences:
                            sentence = sentence.strip()
                            if sentence and len(sentence.split()) > 3:  # Filter very short sentences
                                writer.writerow([label, sentence, '', '', ''])
        
        except Exception as e:
            self.update_status(f"Error processing {pdf_file}: {str(e)} . If this error occurs frequently, please open an issue on the github repo.")
            raise
    
    def process_default_data(self, writer):
        default_file = os.path.join(os.path.dirname(os.path.abspath(__file__)), "default_data.csv")
        self.update_status(f"Using default data from {default_file}")
        
        if not os.path.exists(default_file):
            raise FileNotFoundError(f"Default data file not found at {default_file} . Please check that the default_data.csv file is present. If there is a problem, try downloading it again from the github repository. If this error occurs frequently, please open an issue on the github repo.")
        
        try:
            with open(default_file, 'r', encoding='utf-8') as f:
                reader = csv.reader(f)
                next(reader)  # Skip header
                for row in reader:
                    if row:  # Skip empty rows
                        writer.writerow(['suspicious', row[1], '', '', ''])
        except Exception as e:
            self.update_status(f"Error processing default data: {str(e)} . Please check that the default_data.csv file is clean and not corrupted. If there is a problem, try downloading it again from the github repository. If this error occurs frequently, please open an issue on the github repo.")
            raise
    
    def update_ui_state(self, enabled):
        state = tk.NORMAL if enabled else tk.DISABLED
        self.add_neutral_button.config(state=state)
        self.add_suspicious_button.config(state=tk.DISABLED if self.use_default_var.get() else state)
        self.convert_button.config(state=state)
        self.files_listbox.config(state=state)
    
    def update_status(self, message):
        self.status_label.config(text=message)
        self.root.update()

if __name__ == "__main__":
    root = tk.Tk()
    app = PDFToCSVConverter(root)
    root.mainloop()